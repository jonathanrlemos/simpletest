/** @file tests/cstest/cstest_signal.cpp
 * @brief CloudSync testing framework signal handler.
 * @copyright Copyright (c) 2018 Jonathan Lemos
 *
 * This software may be modified and distributed under the terms
 * of the MIT license.  See the LICENSE file for details.
 */

#include "simpletest_signal.hpp"
#include <unistd.h>
#include <iostream>
#include <cstdlib>

namespace simpletest{

/**
 * @brief Stores the number of instances of this class that are active.
 * This cannot be greater than 1. We do not want more than one SignalHandler class active.
 */
static int instanceCount = 0;

/**
 * @brief Stores the number of the signal thrown.
 * This has to be volatile, otherwise this value may change after a call to longjmp().
 *
 * The volatile keyword denotes that a variable may change asynchronously, which is what appears to happen from the perspective of the signal throwing function.
 */
static volatile sig_atomic_t s_signo = 0;

/**
 * @brief True if the program should exit (SIGABRT, SIGINT, etc.), false if not (SIGSEGV)
 */
static volatile sig_atomic_t s_exit = 0;

/**
 * @brief Stores the execution context of the function to longjmp() to.
 */
static volatile jmp_buf s_jmpbuf;

/**
 * @brief The signals we should capture.
 *
 * SIGINT  - Interrupt signal. Generated by (Ctrl+C) on the keyboard. This signal usually means the user wants to exit, so we let them.
 * SIGABRT - Abort signal. Generated when a library has a fatal error. We usually can't recover from this one, so we exit.
 * SIGSEGV - Segmentation fault. Generated when invalid memory is accessed. This is the signal we want to try to recover from.
 * SIGTERM - Termination signal. Default kill signal for this program. We exit when this happens.
 */
static const sig_atomic_t signals[] = {SIGINT, SIGABRT, SIGSEGV, SIGTERM};

SignalException::SignalException(sig_atomic_t signo): std::runtime_error(SignalHandler::signalToString(signo)), signo(signo){}

sig_atomic_t SignalException::getSignal(){
	return signo;
}

/**
 * @brief Our signal handler.
 * Signal handlers like this are very limited in what they can do, because they can only use re-entrant functions.
 * A re-entrant function is one that you can pause, change any global variables, and re-enter without causing the function to fail.
 *
 * This rules out std::cout/printf() along with almost every C/C++ library function unfortunately, as they rely on global state.
 *
 * However, C89 4.6.2.1 guarantees that longjmp() will execute correctly out of one level of signal handler.
 * It will not correctly execute if the signal handler calls a function that calls longjmp(), but we are calling longjmp() correctly, so we do not have to worry about it.
 *
 * Unfortunately, the function that was executing when the signal threw will not continue, meaning any data it was writing will be in an inconsistent state.
 * Additionally, any non-volatile stack variables may not be the same values they were before the signal was thrown.
 * This is why at our setjmp() point we exit the function as fast as possible by either quitting the program with std::exit(), or throwing a SignalException.
 * @see ActivateSignalHandler()
 *
 */
static void handler(int signo){
	switch (signo){
	case SIGABRT:
	case SIGINT:
	case SIGTERM:
		s_exit = 1;
	}
	s_signo = signo;
	// jump to a previous call to setjmp()
	longjmp(s_jmpbuf, signo);
}

SignalHandler::SignalHandler(){
	// stores data for an action to be taken on a signal throw
	struct sigaction sa;

	// cannot have more than 1 instance of SignalHandler
	if (instanceCount > 0){
		throw new std::logic_error("Cannot have more than one instance of SignalHandler at a time.");
	}
	instanceCount++;

	// set the handler to our handler() function above
	sa.sa_handler = handler;
	// ignore all signals while our handler is active
	sigfillset(&(sa.sa_mask));
	// if a signal was thrown during any non-reentrant library functions (open(), read(), write(), etc.), attempt to continue their execution instead of failing with EINTR
	sa.sa_flags = SA_RESTART;

	// sigaction(SIGINT, &sa, NULL) uses the struct sigaction sa as the handler for SIGINT. The NULL is where the old handler goes, which we do not need.
	for (size_t i = 0; i < sizeof(signals) / sizeof(signals[0]); ++i){
		sigaction(signals[i], &sa, NULL);
	}

	// longjmp() in handler() needs a corresponding setjmp() location, or bad things happen.
	// this gives the handler a default setjmp() location
	if (setjmp(s_jmpbuf)){
		std::cerr << "An ActivateSignalHandler() location was not specified." << std::endl;
		std::exit(1);
	}
}

SignalHandler::SignalHandler(SignalHandler&& other){
	// since this class has no private variables, nothing needs to happen for it to be moved.
	// the following statement silences the unused variable warning
	(void)other;
}

SignalHandler& SignalHandler::operator=(SignalHandler&& other){
	// ditto above
	(void)other;
}

SignalHandler::~SignalHandler(){
	struct sigaction sa;

	instanceCount--;

	sa.sa_handler = SIG_DFL;
	sigfillset(&(sa.sa_mask));
	sa.sa_flags = SA_RESTART;

	for (size_t i = 0; i < sizeof(signals) / sizeof(signals[0]); ++i){
		sigaction(signals[i], &sa, NULL);
	}
}

sig_atomic_t SignalHandler::lastSignal(){
	return s_signo;
}

const char* SignalHandler::signalToString(sig_atomic_t signo){
	switch (signo){
	case SIGINT:
		return "Interrupt signal";
	case SIGABRT:
		return "Abort signal";
	case SIGSEGV:
		return "Segmentation fault";
	case SIGTERM:
		return "Termination signal";
	case 0:
		return "No signal";
	default:
		return "Unknown signal";
	}
}

jmp_buf& SignalHandler::getBuf(){
	return s_jmpbuf;
}

bool SignalHandler::shouldExit(){
	return s_exit;
}

}
