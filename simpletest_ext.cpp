/** @file simpletest_ext.cpp
 * @brief simpletest extended functions.
 * @copyright Copyright (c) 2018 Jonathan Lemos
 *
 * This software may be modified and distributed under the terms
 * of the MIT license.  See the LICENSE file for details.
 */

#include "simpletest_ext.hpp"

#include <algorithm>
#include <cstring>
#include <cerrno>
#include <fstream>
#include <sstream>
#include <sys/stat.h>
#include <unistd.h>

namespace simpletest{

/**
 * @brief Do not use this function directly; instead, use the MAKE_PATH() macro.
 * This function makes a path out of several components.
 * Each component besides the last will have a trailing '/' appended after it.
 * If a component ends with a '/' and the next also starts with a '/', only one '/' is added.
 *
 * @param components A vector containing the components to turn into a path.
 *
 * @return A string corresponding to that path.
 */
static std::string AT_CONST __makepath(std::vector<std::string> components){
	std::string ret;

	// needed so the following line does not throw an out_of_range error if the vector is empty
	if (components.empty()){
		return "";
	}

	ret = components[0];
	// for each component after the first
	for (size_t i = 1; i < components.size(); ++i){
		// if the string does not end with a '/' */
		if (ret[ret.size() - 1] != '/'){
			// append one
			ret += '/';
		}
		// if the string starts with a '/', append everything after the '/', otherwise append the entire string
		ret += (components[i][0] == '/' ? components[i].c_str() + 1 : components[i]);
	}

	return ret;
}

/**
 * @brief Makes a path out of several components.
 * For example:<br>
 * ```C++
 * MAKE_PATH("/home", "equifax", "passwords.txt")     == "/home/equifax/passwords.txt";
 * MAKE_PATH("/home/", "/equifax/", "/passwords.txt") == "/home/equifax/passwords.txt";
 * MAKE_PATH("home/", "/equifax", "/passwords.txt")   == "home/equifax/passwords.txt";
 * ```
 */
#define MAKE_PATH(...) __makepath({__VA_ARGS__})

struct TestEnvironment::TestEnvironmentImpl{
	/**
	 * @brief Vector that holds the files within this test environment.
	 * These files are removed once the TestEnvironment's destructor is called.
	 */
	std::vector<std::string> files;

	/**
	 * @brief Vector that holds the directories within this test environment.
	 * These directories are removed once the TestEnvrionment's destructor is called.
	 */
	std::vector<std::string> directories;

	/**
	 * @brief Destructor for TestEnvironmentImpl.
	 * This removes all files and directories in the files/directories vector.
	 */
	~TestEnvironmentImpl(){
		std::for_each(files.begin(), files.end(), [](const auto& elem){
			chmod(elem.c_str(), 0644);
			remove(elem.c_str());
		});

		std::for_each(directories.begin(), directories.end(), [](const auto& elem){
			chmod(elem.c_str(), 0755);
			rmdir(elem.c_str());
		});
	}

	/**
	 * @brief Creates an empty directory within the test environment and adds it to the directory vector.
	 * This is a helper function for createTestDirectory(), but it can also be used standalone.
	 *
	 * @param path The path of the directory to create.
	 * @param mode The permissions to create the directory with.
	 * By default this is set to 0755, which allows read+write+execute permission for this user and only read+execute for others.
	 */
	void createNewDirectory(const char* path, mode_t mode = 0755){
		// if we could not create the directory, and the directory does not already exist
		if (mkdir(path, mode) != 0 && errno != EEXIST){
			throw std::runtime_error("Failed to create directory " + std::string(path) + '(' + std::strerror(errno) + ')');
		}
		directories.push_back(path);
	}

	/**
	 * @brief Creates a file within the test environment and adds it to the internal file vector.
	 * This is a helper function for createTestDirectory(), but it can also be used standalone.
	 * This file will be filled with random data generated by the fillMemory() function.
	 *
	 * @param path The path of the file to create.
	 * @param mode The mode to create the file with.
	 * By default this is set to 0644, which allows read+write permission for this user and only read for others.
	 * @param maxLen The maximum length of the random data to fill the file with.
	 * By default this is set to 4096, which means that the file will be anywhere from 0 to 4096 bytes.
	 */
	void createTestFile(const char* path, mode_t mode = 0644, size_t maxLen = 4096){
		std::vector<unsigned char> randData;
		// generate a random number from 0 to maxLen
		// this will be the length of the file
		size_t randLen = rand::next() % (maxLen + 1);

		// resize the vector so it can hold the length of data we need.
		randData.resize(randLen);
		// fill the vector with random data
		fillMemory(&(randData[0]), randLen);

		// now create the file using this data
		createFile(path, &(randData[0]), randLen, mode);
		// finally, add the file to our internal file vector
		files.push_back(path);
	}

	/**
	 * @brief Creates a directory within the test environment and fills it with test files.
	 * These files will be created with the following format:
	 * `{path}/{filePrefix}{number}.txt`
	 * The number is 1-indexed.
	 * The files are added to the internal file vector.
	 * Each of these test files will be filled with random data.
	 *
	 * @param path The directory to create.
	 * If this directory's parent does not exist, this function will fail.
	 *
	 * @param filePrefix The prefix to append to each file.
	 * @param nFiles The number of files to create.
	 * @param maxLen The maximum length of the files to create.
	 */
	void createTestDirectory(const char* path, const char* filePrefix = "", int nFiles = 20, size_t maxLen = 4096){
		createNewDirectory(path);

		for (int i = 1; i <= nFiles; ++i){
			// make a path with the following format:
			// {path}/{filePrefix}{number}.txt
			//
			// do not use MAKE_PATH(path, filePrefix, std::to_string(i), ".txt"), because that will make a file with this format: `{path}/{filePrefix}/{number}/.txt`, which is not what we want
			std::string file = MAKE_PATH(path, filePrefix + std::to_string(i) + ".txt");
			createTestFile(file.c_str(), maxLen);
		}
	}
};

void createFile(const char* path, void* mem, size_t memLen, mode_t mode){
	// open an ostream corresponding to the file
	std::ofstream ofs;
	ofs.open(path);
	if (!ofs){
		throw std::runtime_error("Failed to create file " + std::string(path) + " (" + std::strerror(errno) + ")");
	}

	// write the data pointed to by mem literally
	// it has to be cast to a char*, because for some bizarre reason, std::ostream::write() takes a char* instead of a void*/unsigned char*/byte*
	ofs.write((char*)mem, memLen);

	// flush output
	ofs.close();
	// if there were any errors writing
	if (!ofs){
		throw std::runtime_error("Failed to write to file " + std::string(path));
	}

	// finally, chmod our file to the correct mode
	if (chmod(path, mode) != 0){
		std::stringstream ss_oct;
		ss_oct << std::oct << mode;
		throw std::runtime_error("Failed to chmod file " + std::string(path) + " to " + ss_oct.str() + ' ' + std::strerror(errno));
	}
}

void createFile(const char* path, size_t maxRandLen, mode_t mode){
	std::vector<unsigned char> randData;
	// get a random number from 0 to maxRandLen
	size_t randLen = rand::next() % (maxRandLen + 1);

	// resize the vector so it can hold the amount of data we need
	randData.resize(randLen);
	// fill the vector by passing a pointer to its internal unsigned char*
	fillMemory(&(randData[0]), randLen);

	// finally, create the file with this data
	createFile(path, &(randData[0]), randLen, mode);
}

int cmpFile(const char* file1, const char* file2){
	char c1;
	char c2;
	std::ifstream if1;
	std::ifstream if2;

	if1.open(file1);
	if (!if1){
		throw std::runtime_error("Failed to open file " + std::string(file1) + " (" + std::strerror(errno) + ")");
	}
	if2.open(file2);
	if (!if1){
		throw std::runtime_error("Failed to open file " + std::string(file2) + " (" + std::strerror(errno) + ")");
	}

	do{
		c1 = if1.get();
		c2 = if2.get();
	}while (c1 != EOF && c1 == c2);

	return c1 - c2;
}

int cmpFile(const char* file, void* mem, size_t memLen){
	char c1;
	unsigned char* ucmem = (unsigned char*)mem;
	size_t memPtr = 0;
	std::ifstream ifs;

	ifs.open(file);
	if (!ifs){
		throw std::runtime_error("Failed to open file " + std::string(file) + " (" + std::strerror(errno) + ")");
	}

	for (; memPtr < memLen && (c1 = ifs.get()) == ucmem[memPtr]; memPtr++);

	return c1 - ucmem[memPtr];
}

int cmpFile(void* mem, size_t memLen, const char* file){
	return -cmpFile(file, mem, memLen);
}

bool fileExists(const char* file){
	struct stat st;
	if (stat(file, &st) != 0){
		if (errno != ENOENT && errno != ENOTDIR){
			throw std::runtime_error("Failed to stat " + std::string(file) + " (" + std::strerror(errno) + ")");
		}
		return false;
	}
	return S_ISREG(st.st_mode);
}

TestEnvironment::TestEnvironment(): impl(std::make_unique<TestEnvironmentImpl>()){}

TestEnvironment::TestEnvironment(TestEnvironment&& other){
	impl = std::move(other.impl);
}

TestEnvironment& TestEnvironment::operator=(TestEnvironment&& other){
	impl = std::move(other.impl);
	return *this;
}

TestEnvironment::~TestEnvironment(){
	std::for_each(impl->files.begin(), impl->files.end(), [](const auto& elem){
		chmod(elem.c_str(), 0755);
		remove(elem.c_str());
	});

	std::for_each(impl->directories.begin(), impl->directories.end(), [](const auto& elem){
		chmod(elem.c_str(), 0666);
		rmdir(elem.c_str());
	});
}

TestEnvironment& TestEnvironment::setupBasicEnvironment(const char* basePath){
	// seed the rng so we get the same environment every time
	rand::seed(0);

	impl->createNewDirectory(basePath);
	impl->createTestDirectory(basePath, "file");

	std::sort(impl->files.begin(), impl->files.end());
	return *this;
}

TestEnvironment& TestEnvironment::setupFullEnvironment(const char* basePath){
	// seed the rng so we get the same environment every time
	rand::seed(0);

	impl->createNewDirectory(basePath);

	// create 3 test directories under basePath/dir1, basePath/dir2, and basePath/excl
	impl->createTestDirectory(MAKE_PATH(basePath, "dir1").c_str(), "dir1");
	impl->createTestDirectory(MAKE_PATH(basePath, "dir2").c_str(), "dir2");
	impl->createTestDirectory(MAKE_PATH(basePath, "excl").c_str(), "excl");

	// create a file with all blocked permissions under basePath/excl/exclnoacc.txt
	impl->createTestFile(MAKE_PATH(basePath, "excl", "exclnoacc.txt").c_str(), 0000);

	// create a directory with all blocked permissions under basePath/noacc
	impl->createNewDirectory(MAKE_PATH(basePath, "noacc").c_str(), 0000);

	// sort the entries so binary search can be used on them
	std::sort(impl->files.begin(), impl->files.end());
	return *this;
}

const std::vector<std::string>& TestEnvironment::getFiles() const{
	return impl->files;
}

void fillMemory(void* mem, size_t len){
	unsigned char* ucmem = (unsigned char*)mem;
	for (size_t i = 0; i < len; ++i){
		ucmem[i] = rand::next() % ('Z' - 'A') + 'A';
	}
}

namespace rand{

static thread_local unsigned randSeed = 0;

void seed(unsigned seed){
	randSeed = seed;
}

int next(){
	randSeed = 1103515245 * randSeed + 12345;
	return randSeed;
}

}

}
